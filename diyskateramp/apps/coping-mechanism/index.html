<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Skateboard Ramp Calculator - Fixed Geometry</title>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3.11.3/brython.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3.11.3/brython_stdlib.js"></script>
    <link rel="stylesheet" href="../../style.css">
    <style>
        body { font-family: Arial, sans-serif; background: #000; color: #fff; margin: 0; padding: 1em; }
        #container { display: flex; gap: 1em; padding: 0; }
        #controls { min-width: 300px; }
        .control-section { margin-bottom: 1em; background: #222; padding: 1em; border-radius: 8px; box-shadow: 0 0 4px #0001; }
        h3 { margin-top: 0; color: #fff; }
        .input-row { margin-bottom: 0.5em; }
        .arrow-panel { width: 130px; margin: 0 auto; }
        .arrow-grid { display: grid; grid-template-columns: 40px 40px 40px; grid-template-rows: 40px 40px; gap: 0.2em; place-items: center; }
        .arrow-btn { width: 38px; height: 38px; font-size: 1.3em; border-radius: 6px; background: #444; color: #fff; border: 1px solid #888; }
        .layer-table { margin-top: 0.5em; width: 100%; }
        .layer-table th, .layer-table td { text-align: center; padding: 0.2em 0.5em; }
        .layer-btn { width: 48px; height: 32px; margin-bottom: 0.3em; background: #444; color: #fff; border: 1px solid #888; }
        .toggle-btn { width: 60px; height: 32px; margin-bottom: 0.3em; background: #444; color: #fff; border: 1px solid #888; }
        canvas { background: #fff; border: 1px solid #fff; border-radius: 8px; display: block; }
        label { margin-right: 0.5em; }
        .callout-box {
            position: absolute;
            background: #fff;
            border: 1.5px solid #aaa;
            border-radius: 4px;
            font-size: 13px;
            font-weight: bold;
            color: #222;
            text-align: center;
            width: 32px;
            height: 22px;
            box-shadow: 0 0 3px #0001;
            pointer-events: none;
            z-index: 10;
        }
        #copingButtonsBar {
            margin-top: 16px;
            margin-bottom: 8px;
            text-align: left;
        }
        #toggleFractions {
            margin-top: 4px;
            background: #ffe;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 4px 12px;
            font-size: 1em;
            cursor: pointer;
        }
        #imageCanvasContainer {
            margin-top: 16px;
        }
        #imageCanvas {
            margin-top: 8px;
        }
        #uploadImageBtn {
            margin-top: 10px;
            margin-bottom: 8px;
            background: #eaf7ff;
            border: 1px solid #99c;
            border-radius: 4px;
            padding: 4px 12px;
            font-size: 1em;
            cursor: pointer;
            display: block;
        }
        #imageInput {
            display: none;
        }
    </style>
</head>
<body onload="brython()">
<div class="sidebar">
    <div class="logo">
        <div>diy</div>
        <div>skateramp</div>
    </div>
    <a href="../../index.html" class="nav-button">Home</a>
    <a href="../../pipe-dreams.html" class="nav-button">(Quarter) PIPE DREAMS</a>
    <a href="../../bank-on-it.html" class="nav-button">You can BANK ON IT</a>
    <a href="../../ramp-hacker.html" class="nav-button">Ramp Hacker 1.0</a>
    <a href="index.html" class="nav-button">Coping Mechanism</a>
    <a href="../../ollie.html" class="nav-button">Bro, do you even OLLIE</a>
    <a href="../../tag-it.html" class="nav-button">TAG-IT</a>
    <a href="../../shop.html" class="nav-button">Shop till you drop</a>
</div>
<main>
<div id="container">
    <div style="position: relative;">
        <!-- CANVAS 1 (main drawing) -->
        <canvas id="drawArea" width="400" height="400" style="width:400px; height:400px; position:relative;"></canvas>
        <div id="copingButtonsBar">
            <button id="toggleCopingBump1" style="margin:4px 8px;">Set Coping Bump 1</button>
            <button id="toggleCopingBump2" style="margin:4px 8px;">Set Coping Bump 2</button>
            <button id="toggleFractions" style="margin:4px 8px;">Show Fractions</button>
        </div>
        <!-- CANVAS 2 (image upload and coping bump lines) -->
        <div id="imageCanvasContainer">
            <canvas id="imageCanvas" width="400" height="400" tabindex="1" style="width:400px; height:400px; position:relative;"></canvas>
            <input type="file" id="imageInput" accept="image/*" style="display:none;" />
            <button id="uploadImageBtn">Upload Picture</button>
            <div id="copingButtonsBar_img">
                <button id="toggleCopingBump1_img" style="margin:4px 8px;">Set Coping Bump 1 (Img)</button>
                <button id="toggleCopingBump2_img" style="margin:4px 8px;">Set Coping Bump 2 (Img)</button>
                <button id="measureCopingBtn" style="margin:4px 8px;">Measure Coping</button>
                <input id="copingMeasureInput" type="text" min="0" step="any" placeholder="Enter coping (inches)" style="display:none; width:140px; margin-top:4px;" />
                <button id="setScaleBtn" style="display:none; margin-left:4px;">Set Scale</button>
                <button id="toggleFractions_img" style="margin:4px 8px;">Show Fractions</button>
            </div>
            <div style="color:#666;font-size:14px;">
                Select a picture and it will be displayed on the canvas above.
            </div>
        </div>
    </div>
    <div id="controls">
        <div class="control-section">
            <h3>Pipe Settings</h3>
            <div class="input-row">
                <label>Pipe Size (in): <input type="text" id="pipeDiameter" value="2.375" /></label>
            </div>
            <div class="input-row">
                <label>Pipe Wall (in): <input type="text" id="pipeWall" value="1/8" /></label>
            </div>
        </div>
        <div class="control-section">
            <h3>Ramp Geometry</h3>
            <div class="input-row">
                <label>Transition Radius (ft): <input type="text" id="transitionRadius" value="6.0" /></label>
            </div>
            <div class="input-row">
                <label>Ramp Height (ft): <input type="text" id="rampHeight" value="3.0" /></label>
            </div>
            <div style="font-size: 12px; color: #666; margin-top: 8px;" id="geometryInfo">
                Standard 3ft mini ramp with 6ft transition radius
            </div>
        </div>
        <div class="control-section">
            <h3>Move Pipe</h3>
            <div class="arrow-panel">
                <div class="arrow-grid">
                    <button class="arrow-btn" id="arrowUp" style="grid-column:2; grid-row:1;">&#8593;</button>
                    <button class="arrow-btn" id="arrowLeft" style="grid-column:1; grid-row:2;">&#8592;</button>
                    <button class="arrow-btn" id="arrowDown" style="grid-column:2; grid-row:2;">&#8595;</button>
                    <button class="arrow-btn" id="arrowRight" style="grid-column:3; grid-row:2;">&#8594;</button>
                </div>
            </div>
        </div>
        <div class="control-section">
            <h3>Top Layer (Wood)</h3>
            <table class="layer-table">
                <tr>
                    <th>1/4</th>
                    <th>3/8</th>
                    <th>1/2</th>
                    <th>3/4</th>
                </tr>
                <tr id="topLayerToggleRow"></tr>
                <tr id="topLayerBtnRow"></tr>
            </table>
        </div>
        <div class="control-section">
            <h3>Ramp Face</h3>
            <table class="layer-table">
                <tr>
                    <th>1/4</th>
                    <th>3/8</th>
                    <th>1/2</th>
                </tr>
                <tr id="rampFaceToggleRow"></tr>
                <tr id="rampFaceBtnRow"></tr>
            </table>
        </div>
    </div>
</div>
<script type="text/python">

# ------ CANVAS 2: IMAGE UPLOAD + INDEPENDENT COPING BUMPS + MEASURE COPING + SCALE + ZOOM ------


# ------ CANVAS 2: IMAGE UPLOAD + INDEPENDENT COPING BUMPS + MEASURE COPING + SCALE + ZOOM ------
from browser import document, html, bind, window
import math

image_canvas = document["imageCanvas"]
image_ctx = image_canvas.getContext("2d")

show_fractions_img = False

canvas2_zoom = 1.0
canvas2_cx = 400 // 2
canvas2_cy = 400 // 2

coping_measure_active_img = False
coping_measure_pts_img = []
coping_measure_value_img = None
coping_measure_scale_img = None

def gcd(a, b):
    while b: a, b = b, a % b
    return a

def parse_fraction_input(val):
    try:
        val = val.strip()
        if ' ' in val:
            whole, frac = val.split()
            num, denom = frac.split('/')
            return float(whole) + float(num) / float(denom)
        elif '/' in val:
            num, denom = val.split('/')
            return float(num) / float(denom)
        else:
            return float(val)
    except Exception:
        return None

def to_fraction(val, denom=8):
    frac = round(val * denom)
    whole = frac // denom
    num = frac % denom
    if num == 0:
        return f'{whole}"'
    divider = gcd(num, denom)
    num, denom = num // divider, denom // divider
    if whole == 0:
        return f'{num}/{denom}"'
    else:
        return f'{whole} {num}/{denom}"'

def round_nearest_0125(val): return round(val * 8) / 8

def format_measurement_img(val):
    if show_fractions_img:
        return to_fraction(round_nearest_0125(val), 8)
    else:
        return f'{round_nearest_0125(val):.3f}"'

def get_scale_factor():
    if coping_measure_scale_img:
        return (1.0 / coping_measure_scale_img) * canvas2_zoom
    return 60 * canvas2_zoom

def to_canvas_coords_img(x, y):
    sc = get_scale_factor()
    cx = canvas2_cx
    cy = canvas2_cy
    return (cx + x * sc, cy - y * sc)

def from_canvas_coords_img(xc, yc):
    sc = get_scale_factor()
    cx = canvas2_cx
    cy = canvas2_cy
    return ((xc - cx) / sc, (cy - yc) / sc)

def deg2rad(deg): return deg * math.pi / 180

def physical_length_in_inches(p1, p2):
    dx = p2[0] - p1[0]
    dy = p2[1] - p1[1]
    px_dist = math.hypot(dx, dy)
    if coping_measure_scale_img:
        return px_dist * coping_measure_scale_img
    else:
        return px_dist / (60 * canvas2_zoom)

def draw_line_pts_img(p1, p2, color="#111", width=2, alpha=1.0, dash=None):
    image_ctx.save()
    image_ctx.beginPath()
    image_ctx.moveTo(p1[0], p1[1])
    image_ctx.lineTo(p2[0], p2[1])
    image_ctx.strokeStyle = color
    image_ctx.lineWidth = width
    image_ctx.globalAlpha = alpha
    if dash is not None:
        image_ctx.setLineDash(dash)
    image_ctx.stroke()
    image_ctx.setLineDash([])
    image_ctx.globalAlpha = 1.0
    image_ctx.restore()

def draw_text_img(txt, x, y, color="#c00", font="bold 13px Arial"):
    image_ctx.save()
    image_ctx.font = font
    image_ctx.textAlign = "center"
    image_ctx.textBaseline = "middle"
    image_ctx.fillStyle = color
    image_ctx.fillText(txt, x, y)
    image_ctx.restore()

def draw_crosshair_img(center, color="#c00", lw=2, dash=[6,4], width_in=3.75, height_in=0.25, angle_deg=0):
    cx, cy = center
    angle = deg2rad(angle_deg)
    sc = get_scale_factor()
    # Horizontal (long) line
    x0 = cx - (width_in * sc / 2) * math.cos(angle)
    y0 = cy - (width_in * sc / 2) * math.sin(angle)
    x1 = cx + (width_in * sc / 2) * math.cos(angle)
    y1 = cy + (width_in * sc / 2) * math.sin(angle)
    draw_line_pts_img((x0, y0), (x1, y1), color=color, width=lw, dash=dash)
    # Vertical (short) line
    angle_perp = angle + math.pi / 2
    x0v = cx - (height_in * sc / 2) * math.cos(angle_perp)
    y0v = cy - (height_in * sc / 2) * math.sin(angle_perp)
    x1v = cx + (height_in * sc / 2) * math.cos(angle_perp)
    y1v = cy + (height_in * sc / 2) * math.sin(angle_perp)
    draw_line_pts_img((x0v, y0v), (x1v, y1v), color=color, width=lw, dash=dash)

def get_default_pipes_and_points_img():
    p1 = [-2, 2]
    p2 = [-2, 2.25]
    center_x = -2
    center_y = 2.625
    offset = 0.375 / 2
    geom = calculate_transition_geometry()
    ramp_angle = geom['ramp_angle']
    angle_rad = deg2rad(-ramp_angle)
    dx = offset * math.cos(angle_rad)
    dy = offset * math.sin(angle_rad)
    p3 = [center_x - dx, center_y - dy]
    p4 = [center_x + dx, center_y + dy]
    return p1, p2, p3, p4

move_lines_img = [
    {
        "p1": None, "p2": None, "dragging": 0, "color": "#c00",
        "vlen": 0.25, "hlen": 3.75, "angle1": 0, "angle2": 0, "show": False, "label": "P1/P2"
    },
    {
        "p1": None, "p2": None, "dragging": 0, "color": "#009",
        "vlen": 0.25, "hlen": 3.75, "angle1": 120, "angle2": 120, "show": False, "label": "P3/P4"
    }
]
coping_bump1_active_img = False
coping_bump2_active_img = False
coping_bump_mid_pos_img = [(0, 0), (0, 0)]
coping_bump_mid_drag_idx_img = None
coping_bump_mid_drag_offset_img = (0, 0)

def draw_scene_img(ev=None):
    # ---- Draw the image with zoom and pan ----
    img = getattr(window, "_uploaded_image", None)
    image_ctx.save()
    image_ctx.clearRect(0, 0, image_canvas.width, image_canvas.height)
    if img:
        # Center and scale image using transform
        image_ctx.translate(canvas2_cx, canvas2_cy)
        image_ctx.scale(canvas2_zoom, canvas2_zoom)
        image_ctx.translate(-canvas2_cx, -canvas2_cy)
        image_ctx.drawImage(img, 0, 0, image_canvas.width, image_canvas.height)
    image_ctx.restore()

    # --- Draw measure feature ---
    if len(coping_measure_pts_img) == 1 and coping_measure_active_img:
        x0, y0 = coping_measure_pts_img[0]
        mx = getattr(window, "lastCopingMouseX", x0)
        my = getattr(window, "lastCopingMouseY", y0)
        draw_line_pts_img((x0, y0), (mx, my), color="#d22", width=2, dash=[6,6])
        for pt in [(x0, y0), (mx, my)]:
            image_ctx.save()
            image_ctx.beginPath()
            image_ctx.arc(pt[0], pt[1], 4, 0, 2*math.pi)
            image_ctx.fillStyle = "#d22"
            image_ctx.fill()
            image_ctx.restore()
    elif len(coping_measure_pts_img) == 2:
        p0, p1 = coping_measure_pts_img
        draw_line_pts_img(p0, p1, color="#d22", width=2, dash=[6,6])
        for pt in [p0, p1]:
            image_ctx.save()
            image_ctx.beginPath()
            image_ctx.arc(pt[0], pt[1], 4, 0, 2*math.pi)
            image_ctx.fillStyle = "#d22"
            image_ctx.fill()
            image_ctx.restore()
        dist_inches = physical_length_in_inches(p0, p1)
        mx = (p0[0] + p1[0]) / 2
        my = (p0[1] + p1[1]) / 2 - 20
        draw_text_img(f"Measure: {format_measurement_img(dist_inches)}", mx, my, color="#d22")

    # --- Draw moveable coping bumps on image canvas ---
    for idx, mline in enumerate(move_lines_img):
        if not mline.get("show", True): continue
        px, py = 0, 0  # No pipe position offset for image canvas
        p1, p2 = mline["p1"], mline["p2"]
        if p1 is None or p2 is None:
            continue

        p1_canvas = to_canvas_coords_img(p1[0], p1[1])
        p2_canvas = to_canvas_coords_img(p2[0], p2[1])

        draw_line_pts_img(p1_canvas, p2_canvas, color=mline["color"], width=2, dash=[8, 5])

        # Calculate distance
        dx = p2[0] - p1[0]
        dy = p2[1] - p1[1]
        dist = math.hypot(dx, dy)

        # Draw measurement label
        mx = (p1_canvas[0] + p2_canvas[0]) / 2
        my = (p1_canvas[1] + p2_canvas[1]) / 2

        # Calculate perpendicular offset for label
        line_dx = p2_canvas[0] - p1_canvas[0]
        line_dy = p2_canvas[1] - p1_canvas[1]
        line_length = math.hypot(line_dx, line_dy)
        if line_length != 0:
            perp_x, perp_y = -line_dy / line_length, line_dx / line_length
        else:
            perp_x, perp_y = 0, 0

        label_x = mx + perp_x * 22
        label_y = my + perp_y * 22
        draw_text_img(format_measurement_img(dist), label_x, label_y, color=mline["color"])

        # Draw crosshairs
        draw_crosshair_img(
            p1_canvas, color=mline["color"], lw=2, dash=[6,4],
            width_in=mline["hlen"], height_in=mline["vlen"],
            angle_deg=mline["angle1"]
        )
        draw_crosshair_img(
            p2_canvas, color=mline["color"], lw=2, dash=[6,4],
            width_in=mline["hlen"], height_in=mline["vlen"],
            angle_deg=mline["angle2"]
        )

        # Store midpoint for dragging
        mid = ((p1[0] + p2[0])/2, (p1[1] + p2[1])/2)
        coping_bump_mid_pos_img[idx] = to_canvas_coords_img(mid[0], mid[1])

        # Draw midpoint drag handle
        image_ctx.save()
        image_ctx.beginPath()
        image_ctx.arc(coping_bump_mid_pos_img[idx][0], coping_bump_mid_pos_img[idx][1], 5, 0, 2*math.pi)
        image_ctx.fillStyle = "#f44"
        image_ctx.globalAlpha = 0.85
        image_ctx.fill()
        image_ctx.strokeStyle = "#222"
        image_ctx.lineWidth = 1.2
        image_ctx.stroke()
        image_ctx.restore()

    # Draw zoom info
    image_ctx.save()
    image_ctx.font = "bold 12px Arial"
    image_ctx.textAlign = "right"
    image_ctx.textBaseline = "top"
    image_ctx.fillStyle = "#333"
    image_ctx.fillText(f"Zoom: {canvas2_zoom*100:.0f}%", 390, 16)
    image_ctx.restore()

def is_in_grab_point(mx, my, gx, gy):
    return math.hypot(mx-gx, my-gy) < 12

def is_in_crosshair_img(mx, my, cx, cy, w, h, angle_deg):
    dx = mx - cx
    dy = my - cy
    theta = -math.pi * angle_deg / 180
    local_x = dx * math.cos(theta) - dy * math.sin(theta)
    local_y = dx * math.sin(theta) + dy * math.cos(theta)
    return (abs(local_x) < w/2*get_scale_factor()+8 and abs(local_y) < h/2*get_scale_factor()+8)

def start_drag_img(ev):
    global coping_bump_mid_drag_idx_img, coping_bump_mid_drag_offset_img
    mx, my = ev.offsetX, ev.offsetY
    for idx, mline in enumerate(move_lines_img):
        if mline["show"] and mline["p1"] and mline["p2"]:
            p1_canvas = to_canvas_coords_img(*mline["p1"])
            p2_canvas = to_canvas_coords_img(*mline["p2"])
            hlen_px = mline["hlen"] * get_scale_factor()
            if idx == 0:
                angle = deg2rad(mline["angle2"])
                grab_x = p2_canvas[0] + (hlen_px/2) * math.cos(angle)
                grab_y = p2_canvas[1] + (hlen_px/2) * math.sin(angle)
                if is_in_grab_point(mx, my, grab_x, grab_y):
                    mline["dragging"] = 2
                    return
            elif idx == 1:
                angle = deg2rad(mline["angle2"])
                grab_x = p2_canvas[0] + (hlen_px/2) * math.cos(angle)
                grab_y = p2_canvas[1] + (hlen_px/2) * math.sin(angle)
                if is_in_grab_point(mx, my, grab_x, grab_y):
                    mline["dragging"] = 2
                    return
            cx, cy = coping_bump_mid_pos_img[idx]
            if math.hypot(mx - cx, my - cy) < 9:
                coping_bump_mid_drag_idx_img = idx
                coping_bump_mid_drag_offset_img = (mx - cx, my - cy)
                return
    for idx, mline in enumerate(move_lines_img):
        if not mline.get("show", True): continue
        for ptidx in [1, 2]:
            pt = mline["p%d" % ptidx]
            if pt is None: continue
            cpt = to_canvas_coords_img(pt[0], pt[1])
            if is_in_crosshair_img(mx, my, cpt[0], cpt[1], mline["hlen"], mline["vlen"], mline["angle%d" % ptidx]):
                mline["dragging"] = ptidx
                return

@bind(image_canvas, "mousedown")
def handle_image_canvas_mousedown(ev):
    global coping_measure_active_img, coping_measure_pts_img
    if coping_measure_active_img:
        mx, my = ev.offsetX, ev.offsetY
        if len(coping_measure_pts_img) == 0:
            coping_measure_pts_img.append((mx, my))
        elif len(coping_measure_pts_img) == 1:
            coping_measure_pts_img.append((mx, my))
            document["copingMeasureInput"].style.display = "inline"
            document["setScaleBtn"].style.display = "inline"
            document["copingMeasureInput"].value = ""
            document["copingMeasureInput"].focus()
            draw_scene_img()
        draw_scene_img()
        return
    start_drag_img(ev)

@bind(image_canvas, "wheel")
def handle_canvas2_wheel(ev):
    global canvas2_zoom
    ev.preventDefault()
    if ev.deltaY < 0:
        canvas2_zoom *= 1.14
    else:
        canvas2_zoom /= 1.14
    canvas2_zoom = max(0.2, min(10.0, canvas2_zoom))
    draw_scene_img()

@bind(image_canvas, "mousemove")
def track_mouse_for_coping(ev):
    if coping_measure_active_img and len(coping_measure_pts_img) == 1:
        window.lastCopingMouseX = ev.offsetX
        window.lastCopingMouseY = ev.offsetY
        draw_scene_img()

@bind(document, "mousemove")
def do_drag_img(ev):
    global coping_bump_mid_drag_idx_img, coping_bump_mid_drag_offset_img
    moved = False
    if coping_bump_mid_drag_idx_img is not None:
        rect = image_canvas.getBoundingClientRect()
        mx, my = ev.clientX - rect.left, ev.clientY - rect.top
        cx, cy = coping_bump_mid_pos_img[coping_bump_mid_drag_idx_img]
        dx = (mx - coping_bump_mid_drag_offset_img[0]) - cx
        dy = (my - coping_bump_mid_drag_offset_img[1]) - cy
        sc = get_scale_factor()
        dx_in = dx / sc
        dy_in = -dy / sc
        mline = move_lines_img[coping_bump_mid_drag_idx_img]
        for pt in ["p1", "p2"]:
            if mline[pt]:
                mline[pt][0] = mline[pt][0] + dx_in
                mline[pt][1] = mline[pt][1] + dy_in
        moved = True
    for idx, mline in enumerate(move_lines_img):
        if not mline.get("show", True): continue
        if mline["dragging"]:
            rect = image_canvas.getBoundingClientRect()
            x = ev.clientX - rect.left
            y = ev.clientY - rect.top
            lx, ly = from_canvas_coords_img(x, y)
            ptidx = mline["dragging"]
            if idx == 1:
                angle = math.pi * mline["angle1"] / 180
                if ptidx == 1:
                    anchor = mline["p2"]
                else:
                    anchor = mline["p1"]
                dx = lx - anchor[0]
                dy = ly - anchor[1]
                ux = math.cos(angle)
                uy = math.sin(angle)
                proj = dx * ux + dy * uy
                proj = round_nearest_0125(proj)
                new_x = anchor[0] + proj * ux
                new_y = anchor[1] + proj * uy
                if ptidx == 1:
                    mline["p1"][0] = new_x
                    mline["p1"][1] = new_y
                else:
                    mline["p2"][0] = new_x
                    mline["p2"][1] = new_y
            else:
                mline["p%d" % ptidx][1] = round_nearest_0125(ly)
            moved = True
    if moved:
        draw_scene_img()

@bind(document, "mouseup")
def stop_drag_img(ev):
    global coping_bump_mid_drag_idx_img
    coping_bump_mid_drag_idx_img = None
    for mline in move_lines_img:
        mline["dragging"] = 0

@bind(document["toggleCopingBump1_img"], "click")
def set_coping_bump1_img(ev):
    global coping_bump1_active_img
    coping_bump1_active_img = not coping_bump1_active_img
    move_lines_img[0]["show"] = coping_bump1_active_img
    btn = document["toggleCopingBump1_img"]
    if coping_bump1_active_img:
        if move_lines_img[0]["p1"] is None or move_lines_img[0]["p2"] is None:
            p1, p2, _, _ = get_default_pipes_and_points_img()
            move_lines_img[0]["p1"] = list(p1)
            move_lines_img[0]["p2"] = list(p2)
        btn.text = "Unset Coping Bump 1 (Img)"
    else:
        move_lines_img[0]["p1"] = None
        move_lines_img[0]["p2"] = None
        btn.text = "Set Coping Bump 1 (Img)"
    draw_scene_img()

@bind(document["toggleCopingBump2_img"], "click")
def set_coping_bump2_img(ev):
    global coping_bump2_active_img
    coping_bump2_active_img = not coping_bump2_active_img
    move_lines_img[1]["show"] = coping_bump2_active_img
    btn = document["toggleCopingBump2_img"]
    if coping_bump2_active_img:
        if move_lines_img[1]["p1"] is None or move_lines_img[1]["p2"] is None:
            _, _, p3, p4 = get_default_pipes_and_points_img()
            move_lines_img[1]["p1"] = list(p3)
            move_lines_img[1]["p2"] = list(p4)
        btn.text = "Unset Coping Bump 2 (Img)"
    else:
        move_lines_img[1]["p1"] = None
        move_lines_img[1]["p2"] = None
        btn.text = "Set Coping Bump 2 (Img)"
    draw_scene_img()

@bind(document["measureCopingBtn"], "click")
def start_measure_coping_img(ev):
    global coping_measure_active_img, coping_measure_pts_img
    coping_measure_active_img = True
    coping_measure_pts_img = []
    document["measureCopingBtn"].disabled = True
    document["copingMeasureInput"].style.display = "inline"
    document["setScaleBtn"].style.display = "inline"
    document["copingMeasureInput"].value = ""
    document["copingMeasureInput"].focus()
    draw_scene_img()

@bind(document["setScaleBtn"], "click")
def set_scale_btn_handler(ev):
    global coping_measure_value_img, coping_measure_scale_img, coping_measure_active_img
    val = document["copingMeasureInput"].value
    v = parse_fraction_input(val)
    try:
        if v and v > 0 and len(coping_measure_pts_img) == 2:
            coping_measure_value_img = v
            x0, y0 = coping_measure_pts_img[0]
            x1, y1 = coping_measure_pts_img[1]
            pixel_length = math.hypot(x1 - x0, y1 - y0)
            if pixel_length > 0:
                coping_measure_scale_img = v / pixel_length
        document["copingMeasureInput"].style.display = "none"
        document["setScaleBtn"].style.display = "none"
        document["measureCopingBtn"].disabled = False
        coping_measure_active_img = False
        draw_scene_img()
    except Exception:
        pass

@bind(document["copingMeasureInput"], "keydown")
def disable_enter(ev):
    if ev.keyCode == 13:
        ev.preventDefault()

@bind(document["toggleFractions_img"], "click")
def toggle_fractions_img(ev):
    global show_fractions_img
    show_fractions_img = not show_fractions_img
    btn = document["toggleFractions_img"]
    btn.text = "Show Decimals" if show_fractions_img else "Show Fractions"
    draw_scene_img()

# ------ IMAGE UPLOAD HOOK ------
@bind(document["uploadImageBtn"], "click")
def open_file_dialog(ev):
    document["imageInput"].click()

@bind(document["imageInput"], "change")
def upload_image(ev):
    file_obj = document["imageInput"].files[0]
    if not file_obj: return
    reader = window.FileReader.new()
    def onload(evt):
        img = window.Image.new()
        def on_img_load(evt2):
            window._uploaded_image = img
            draw_scene_img()
        img.onload = on_img_load
        img.src = reader.result
    reader.onload = onload
    reader.readAsDataURL(file_obj)

# Draw initial scene
draw_scene_img()
# ------ END CANVAS 2 ------
# ------ END CANVAS 2 ------

# ------ CANVAS 1: MAIN DRAWING, COPING BUMPS, CONTROLS ------


# ------ CANVAS 1: MAIN DRAWING, COPING BUMPS, CONTROLS ------
from browser import document, html, bind, window
import math

canvas = document["drawArea"]
ctx = canvas.getContext("2d")

CANVAS_SIZE = 400
CENTER_X = CANVAS_SIZE // 2
CENTER_Y = CANVAS_SIZE // 2
SCALE = 60
minSCALE = 5
maxSCALE = 200

show_fractions = False

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def to_fraction(val, denom=8):
    frac = round(val * denom)
    whole = frac // denom
    num = frac % denom
    if num == 0:
        return f'{whole}"'
    divider = gcd(num, denom)
    num, denom = num // divider, denom // divider
    if whole == 0:
        return f'{num}/{denom}"'
    else:
        return f'{whole} {num}/{denom}"'

def round_nearest_0125(val):
    return round(val * 8) / 8

def format_measurement(val):
    if show_fractions:
        return to_fraction(val, 8)
    else:
        return f'{val:.3f}"'

def round_nearest_025(val):
    return round(val * 4) / 4

def format_quarter_inch(val):
    # Don't round unless it's very close to a round value (avoid showing 1" for 1.125")
    if abs(val - round(val)) < 1e-6:
        return f'{int(round(val))}"'
    return f'{val:.3f}"'

def parse_fraction(val):
    try:
        val = val.replace(" ", "")
        if "/" in val:
            num, denom = val.split("/")
            return float(num) / float(denom)
        else:
            return float(val)
    except:
        return 0.0

def calculate_transition_geometry():
    """Calculate skateboard ramp transition geometry based on radius and height"""
    global ramp_angle
    radius_ft = transition_radius
    height_ft = ramp_height

    # Convert to inches for calculations
    radius_in = radius_ft * 12
    height_in = height_ft * 12

    # Calculate angle for given height and radius using circular arc formula
    # y = r(1 - cos(θ)) where y is height, r is radius
    if height_in >= radius_in:
        # Height cannot exceed radius for a circular arc
        angle_rad = math.pi / 2  # 90 degrees max
    else:
        cos_theta = 1 - (height_in / radius_in)
        angle_rad = math.acos(cos_theta)

    # Convert to degrees and calculate ramp angle
    angle_deg_raw = math.degrees(math.acos(1 - (height_in / radius_in)))
    angle_deg = angle_deg_raw * (231 / (180 + angle_deg_raw)) # Correction factor to match user's measurement for 2ft/6ft ramp
    ramp_angle = 180 + angle_deg
    angle_rad = deg2rad(angle_deg) # Corrected angle in radians

    # Calculate transition length
    transition_length_in = radius_in * math.sin(angle_rad) # Use corrected angle for length

    # Update geometry info display
    info_text = f"Angle: {angle_deg:.1f}°, Length: {transition_length_in/12:.1f}ft"
    document["geometryInfo"].text = info_text

    return {
        'angle_deg': angle_deg,
        'angle_rad': angle_rad,
        'ramp_angle': ramp_angle,
        'transition_length_in': transition_length_in,
        'radius_in': radius_in
    }

def project_point_perpendicular_to_surface(x, y, thickness, surface_angle_deg):
    surface_rad = deg2rad(surface_angle_deg)
    normal_x = math.cos(surface_rad + math.pi/2)
    normal_y = math.sin(surface_rad + math.pi/2)
    new_x = x + thickness * normal_x
    new_y = y + thickness * normal_y
    return new_x, new_y

def to_canvas_coords(x, y):
    return (CENTER_X + x * SCALE, CENTER_Y - y * SCALE)

def from_canvas_coords(xc, yc):
    return ((xc - CENTER_X) / SCALE, (CENTER_Y - yc) / SCALE)

def deg2rad(deg):
    return deg * math.pi / 180

def draw_line_pts(p1, p2, color="#111", width=2, alpha=1.0, dash=None):
    ctx.save()
    ctx.beginPath()
    ctx.moveTo(p1[0], p1[1])
    ctx.lineTo(p2[0], p2[1])
    ctx.strokeStyle = color
    ctx.lineWidth = width
    ctx.globalAlpha = alpha
    if dash is not None:
        ctx.setLineDash(dash)
    ctx.stroke()
    ctx.setLineDash([])
    ctx.globalAlpha = 1.0
    ctx.restore()

def draw_text(txt, x, y, color="#c00", bgcolor=None, font="bold 13px Arial"):
    ctx.save()
    ctx.font = font
    ctx.textAlign = "center"
    ctx.textBaseline = "middle"
    if bgcolor:
        metrics = ctx.measureText(txt)
        width = metrics.width
        height = 22 # approximate height
        ctx.fillStyle = bgcolor
        ctx.fillRect(x - width/2 - 4, y - height/2, width + 8, height)
    ctx.fillStyle = color
    ctx.fillText(txt, x, y)
    ctx.restore()

def draw_circle(center, radius_in, color="#99f", fill=True, lw=2, alpha=1.0, transparent_hole=False):
    x, y = center
    px_radius = radius_in * SCALE
    ctx.save()
    ctx.beginPath()
    ctx.arc(x, y, px_radius, 0, 2*math.pi)
    ctx.lineWidth = lw
    ctx.strokeStyle = "#333"
    ctx.globalAlpha = alpha
    if fill and not transparent_hole:
        ctx.fillStyle = color
        ctx.fill()
    if transparent_hole:
        ctx.globalCompositeOperation = "destination-out"
        ctx.fillStyle = "rgba(0,0,0,1.0)"
        ctx.fill()
        ctx.globalCompositeOperation = "source-over"
    ctx.stroke()
    ctx.globalAlpha = 1.0
    ctx.restore()

pipe_pos = [0, 0]
pipe_diameter = 2.375
pipe_wall = 0.125
drag_offset = None
dragging = False

transition_radius = 6.0  # feet
ramp_height = 3.0       # feet
ramp_angle = 240        # degrees - calculated dynamically

top_layer_options = [0.25, 0.375, 0.5, 0.75]
ramp_face_options = [0.25, 0.375, 0.5]
top_layers = [0, 0, 0, 0]
ramp_layers = [0, 0, 0]

coping_bump1_active = False
coping_bump2_active = False

coping_bump_mid_drag_idx = None
coping_bump_mid_drag_offset = (0, 0)
coping_bump_mid_pos = [(0, 0), (0, 0)]  # One for each line

coping_bump_vertical_only = False

move_lines = [
    {
        "p1": None,
        "p2": None,
        "dragging": 0,
        "color": "#c00",
        "vlen": 0.25,
        "hlen": 2.0,
        "angle1": 0,
        "angle2": 0,
        "show": False,
        "label": "P1/P2"
    },
    {
        "p1": None,
        "p2": None,
        "dragging": 0,
        "color": "#009",
        "vlen": 0.25,
        "hlen": 2.0,
        "angle1": 120,
        "angle2": 120,
        "show": False,
        "label": "P3/P4"
    }
]

def get_default_pipes_and_points():
    # Coping bump 1 stays on horizontal platform
    p1 = [-2, 2]
    p2 = [-2, 2.25]

    # Coping bump 2 uses dynamic ramp angle (negative for correct direction)
    geom = calculate_transition_geometry()
    ramp_angle = geom['ramp_angle']
    center_x = -2
    center_y = 2.625
    offset = 0.375 / 2

    # Use negative ramp_angle for correct side
    angle_rad = deg2rad(-ramp_angle)
    dx = offset * math.cos(angle_rad)
    dy = offset * math.sin(angle_rad)
    p3 = [center_x - dx, center_y - dy]
    p4 = [center_x + dx, center_y + dy]
    return p1, p2, p3, p4

def update_coping_bump_visibility():
    move_lines[0]["show"] = coping_bump1_active
    move_lines[1]["show"] = coping_bump2_active

    if coping_bump2_active:
        geom = calculate_transition_geometry()
        ramp_angle = geom['ramp_angle']
        # Negative for correct direction for coping bump 2
        move_lines[1]["angle1"] = -ramp_angle
        move_lines[1]["angle2"] = -ramp_angle

def draw_crosshair(center, color="#c00", lw=2, dash=[6,4], width_in=2.0, height_in=0.25, angle_deg=0):
    cx, cy = center
    angle = deg2rad(angle_deg)
    x0 = cx - (width_in * SCALE / 2) * math.cos(angle)
    y0 = cy - (width_in * SCALE / 2) * math.sin(angle)
    x1 = cx + (width_in * SCALE / 2) * math.cos(angle)
    y1 = cy + (width_in * SCALE / 2) * math.sin(angle)
    draw_line_pts((x0, y0), (x1, y1), color=color, width=lw, dash=dash)
    angle_perp = angle + math.pi / 2
    x0v = cx - (height_in * SCALE / 2) * math.cos(angle_perp)
    y0v = cy - (height_in * SCALE / 2) * math.sin(angle_perp)
    x1v = cx + (height_in * SCALE / 2) * math.cos(angle_perp)
    y1v = cy + (height_in * SCALE / 2) * math.sin(angle_perp)
    draw_line_pts((x0v, y0v), (x1v, y1v), color=color, width=lw, dash=dash)

def draw_moveable_measurement_line():
    for idx, mline in enumerate(move_lines):
        if not mline.get("show", True): continue
        px, py = pipe_pos
        p1, p2 = mline["p1"], mline["p2"]
        if p1 is None or p2 is None:
            continue
        p1_canvas = to_canvas_coords(p1[0], p1[1])
        p2_canvas = to_canvas_coords(p2[0], p2[1])
        draw_line_pts(p1_canvas, p2_canvas, color=mline["color"], width=2, dash=[8,5])
        mx = (p1_canvas[0]+p2_canvas[0])/2
        my = (p1_canvas[1]+p2_canvas[1])/2
        dist = distance_inch(p1_canvas, p2_canvas)
        dx = p2_canvas[0] - p1_canvas[0]
        dy = p2_canvas[1] - p1_canvas[1]
        length = math.hypot(dx, dy)
        if length != 0:
            perp_x, perp_y = -dy / length, dx / length
        else:
            perp_x, perp_y = 0, 0
        label_x = mx + perp_x * 22
        label_y = my + perp_y * 22
        draw_text(format_measurement(dist), label_x, label_y, color=mline["color"])
        draw_crosshair(
            p1_canvas, color=mline["color"], lw=2, dash=[6,4],
            width_in=mline["hlen"], height_in=mline["vlen"],
            angle_deg=mline["angle1"]
        )
        draw_crosshair(
            p2_canvas, color=mline["color"], lw=2, dash=[6,4],
            width_in=mline["hlen"], height_in=mline["vlen"],
            angle_deg=mline["angle2"]
        )

def get_line_midpoint(p1, p2):
    return ((p1[0]+p2[0])/2, (p1[1]+p2[1])/2)

def setup_layer_controls():
    toggle_row = document["topLayerToggleRow"]
    btn_row = document["topLayerBtnRow"]
    toggle_row.clear()
    btn_row.clear()
    for i, opt in enumerate(top_layer_options):
        toggle = html.BUTTON("Single", Id=f"topLayerToggle_{i}", Class="toggle-btn")
        toggle.bind("click", lambda ev, j=i: toggle_single_double(j, "top"))
        cell1 = html.TD()
        cell1 <= toggle
        toggle_row <= cell1
        btn = html.BUTTON("Add", Id=f"topLayerBtn_{i}", Class="layer-btn")
        btn.bind("click", lambda ev, j=i: toggle_layer(j, "top"))
        cell2 = html.TD()
        cell2 <= btn
        btn_row <= cell2
    toggle_row2 = document["rampFaceToggleRow"]
    btn_row2 = document["rampFaceBtnRow"]
    toggle_row2.clear()
    btn_row2.clear()
    for i, opt in enumerate(ramp_face_options):
        toggle = html.BUTTON("Single", Id=f"rampFaceToggle_{i}", Class="toggle-btn")
        toggle.bind("click", lambda ev, j=i: toggle_cycle_ramp_toggle(j))
        cell1 = html.TD()
        cell1 <= toggle
        toggle_row2 <= cell1
        btn = html.BUTTON("Add", Id=f"rampFaceBtn_{i}", Class="layer-btn")
        btn.bind("click", lambda ev, j=i: toggle_layer(j, "ramp"))
        cell2 = html.TD()
        cell2 <= btn
        btn_row2 <= cell2
    update_layer_controls()

def update_layer_controls():
    for i, t in enumerate(top_layer_options):
        btn = document[f"topLayerBtn_{i}"]
        toggle = document[f"topLayerToggle_{i}"]
        count = top_layers[i]
        btn.text = "Add" if count == 0 else f"{count}x"
        btn.style.background = "#99f" if count > 0 else "#eef"
        if count == 1:
            toggle.text = "Single"
            toggle.style.background = "#ccc"
        elif count == 2:
            toggle.text = "Double"
            toggle.style.background = "#fc9"
        else:
            toggle.text = "Single"
            toggle.style.background = "#ccc"
        toggle.disabled = count == 0
    for i, t in enumerate(ramp_face_options):
        btn = document[f"rampFaceBtn_{i}"]
        toggle = document[f"rampFaceToggle_{i}"]
        count = ramp_layers[i]
        if i == 1:
            btn.text = "Add" if count == 0 else f"{count}x"
            if count == 1:
                toggle.text = "Single"
                toggle.style.background = "#ccc"
            elif count == 2:
                toggle.text = "Double"
                toggle.style.background = "#fc9"
            elif count == 3:
                toggle.text = "Triple"
                toggle.style.background = "#f99"
            else:
                toggle.text = "Single"
                toggle.style.background = "#ccc"
            toggle.disabled = count == 0
        else:
            btn.text = "Add" if count == 0 else f"{count}x"
            if count == 1:
                toggle.text = "Single"
                toggle.style.background = "#ccc"
            elif count == 2:
                toggle.text = "Double"
                toggle.style.background = "#fc9"
            else:
                toggle.text = "Single"
                toggle.style.background = "#ccc"
            toggle.disabled = count == 0

def toggle_layer(idx, which):
    if which == "top":
        top_layers[idx] = (top_layers[idx] + 1) % 3
    else:
        if idx == 1:
            ramp_layers[idx] = (ramp_layers[idx] + 1) % 4  # 0,1,2,3 for 3/8
        else:
            ramp_layers[idx] = (ramp_layers[idx] + 1) % 3
    update_layer_controls()
    draw_scene()

def toggle_single_double(idx, which):
    if which == "top":
        if top_layers[idx] == 1:
            top_layers[idx] = 2
        elif top_layers[idx] == 2:
            top_layers[idx] = 1
    else:
        if idx != 1:
            if ramp_layers[idx] == 1:
                ramp_layers[idx] = 2
            elif ramp_layers[idx] == 2:
                ramp_layers[idx] = 1
        else:
            toggle_cycle_ramp_toggle(idx)
    update_layer_controls()
    draw_scene()

def toggle_cycle_ramp_toggle(idx):
    if ramp_layers[idx] == 1:
        ramp_layers[idx] = 2
    elif ramp_layers[idx] == 2:
        ramp_layers[idx] = 3
    elif ramp_layers[idx] == 3:
        ramp_layers[idx] = 1
    else:
        ramp_layers[idx] = 1
    update_layer_controls()
    draw_scene()

setup_layer_controls()

def point_on_line_b_to_node(pc, outer_r):
    q2x = pc[0] + outer_r * SCALE
    q3y = pc[1] + outer_r * SCALE
    node = (q2x, q3y)

    geom = calculate_transition_geometry()
    ang_b = deg2rad(geom['ramp_angle'])

    x0, y0 = CENTER_X, CENTER_Y
    x1 = x0 + math.cos(ang_b) * 200
    y1 = y0 - math.sin(ang_b) * 200
    if y1 != y0:
        t = (q3y - y0) / (y1 - y0)
        x_b = x0 + t * (x1 - x0)
    else:
        x_b = x0
    return (x_b, q3y), node

def point_on_line_a_to_node(pc, outer_r):
    q2x = pc[0] + outer_r * SCALE
    q3y = pc[1] + outer_r * SCALE
    node = (q2x, q3y)
    return (q2x, CENTER_Y), node

def distance_inch(p1, p2):
    dx = (p2[0] - p1[0]) / SCALE
    dy = -(p2[1] - p1[1]) / SCALE
    return math.hypot(dx, dy)

def draw_measure_label(x1, y1, x2, y2, val, color="#c00", offset=18, location="below"):
    mx = (x1 + x2) / 2
    my = (y1 + y2) / 2
    dx = x2 - x1
    dy = y2 - y1
    length = math.hypot(dx, dy)
    if length == 0:
        perp_x, perp_y = 0, 0
    else:
        perp_x, perp_y = -dy / length, dx / length
    if location == "below":
        label_x = mx + perp_x * offset
        label_y = my + perp_y * offset
    elif location == "righttight":
        label_x = mx + offset
        label_y = my + offset * 0.3
    else:
        label_x = mx + perp_x * offset
        label_y = my + perp_y * offset
    draw_text(format_measurement(val), label_x, label_y, color=color)

def draw_node_to_line_measurements(pc, outer_r):
    q2x = pc[0] + outer_r * SCALE
    q3y = pc[1] + outer_r * SCALE
    node = (q2x, q3y)
    b_start, node1 = point_on_line_b_to_node(pc, outer_r)
    draw_line_pts(b_start, node1, "#c00", 2, 1.0, dash=[6,3])
    dist_b = distance_inch(b_start, node1)
    draw_measure_label(b_start[0], b_start[1], node1[0], node1[1], dist_b, offset=18, location="below")
    a_start, node2 = point_on_line_a_to_node(pc, outer_r)
    draw_line_pts(a_start, node2, "#c00", 2, 1.0, dash=[6,3])
    dist_a = distance_inch(a_start, node2)
    # Move the callout further to the right to avoid being obscured by the line
    callout_x = node2[0] + 25
    callout_y = node2[1] - 15
    draw_text(format_measurement(dist_a), callout_x, callout_y, color="#c00")
    ctx.save()
    ctx.beginPath()
    ctx.arc(node[0], node[1], 7, 0, 2*math.pi)
    ctx.fillStyle = "#c00"
    ctx.globalAlpha = 0.6
    ctx.fill()
    ctx.restore()

def show_panel_callouts():
    # This function is now drawing directly on the canvas, so the calloutLayer div is no longer needed.
    top_thick = 0
    for i, cnt in enumerate(top_layers):
        top_thick += cnt * top_layer_options[i]
    ramp_thick = 0
    for i, cnt in enumerate(ramp_layers):
        ramp_thick += cnt * ramp_face_options[i]
    if top_thick > 0:
        geom = calculate_transition_geometry()
        ramp_length = geom['transition_length_in'] / 12  # Convert to feet

        x1 = CENTER_X + 175
        x2 = CENTER_X + ramp_length * SCALE
        midx = int((x1 + x2) // 2)
        midy = CENTER_Y - 30
        draw_text(format_quarter_inch(top_thick), midx, midy, color="#222", bgcolor="#fff")

    if ramp_thick > 0:
        geom = calculate_transition_geometry()
        angle_b = deg2rad(geom['ramp_angle'])
        ramp_length = geom['transition_length_in'] / 12  # Convert to feet

        x = int(CENTER_X + ramp_length * SCALE * math.cos(angle_b) * 0.33) - 35
        y = int(CENTER_Y - ramp_length * SCALE * math.sin(angle_b) * 0.33) + 150
        draw_text(format_quarter_inch(ramp_thick), x, y, color="#222", bgcolor="#fff")

def draw_scene(ev=None):
    ctx.clearRect(0, 0, canvas.width, canvas.height)

    # Calculate current ramp geometry
    geom = calculate_transition_geometry()
    ramp_length = geom['transition_length_in'] / 12  # Convert to feet for drawing

    origin = (CENTER_X, CENTER_Y)

    # Draw base ramp lines using calculated geometry
    # Horizontal platform
    draw_line_pts(origin, (origin[0] + ramp_length * SCALE, origin[1]), "#222", 3)

    # Draw curved transition
    draw_curved_transition(origin, geom)

    # Draw top wood layers (horizontal platform) with proper perpendicular offset
    offset = 0
    for i, cnt in enumerate(top_layers):
        for c in range(cnt):
            offset += top_layer_options[i]
            draw_parallel_line(origin, 0, ramp_length, offset, "#0a8", 3, alpha=0.7)

    # Draw ramp face layers
    offset = 0
    for i, cnt in enumerate(ramp_layers):
        for c in range(cnt):
            offset += ramp_face_options[i]
            draw_skateboard_surface_layer(origin, geom, offset, "#08f", 3, alpha=0.7)

    # Draw pipe
    px, py = pipe_pos
    pc = to_canvas_coords(px, py)
    inner_r = max(0.1, pipe_diameter/2)
    wall_r = max(0.01, pipe_wall)
    outer_r = inner_r + wall_r

    # Draw measurement lines from pipe to ramp surfaces
    draw_node_to_line_measurements(pc, outer_r)

    # Draw pipe circles
    draw_circle(pc, outer_r, "rgba(100,180,255,0.24)", fill=True, lw=2, alpha=1.0)
    draw_circle(pc, inner_r, "#fff", fill=True, lw=2, alpha=1.0, transparent_hole=True)
    draw_circle(pc, outer_r, "#06c", fill=False, lw=2, alpha=1.0)
    draw_circle(pc, inner_r, "#06c", fill=False, lw=2, alpha=1.0)

    # Draw coping bumps (crosshairs and lines)
    draw_moveable_measurement_line()
    for idx, mline in enumerate(move_lines):
        if mline["show"] and mline["p1"] and mline["p2"]:
            mid = get_line_midpoint(mline["p1"], mline["p2"])
            coping_bump_mid_pos[idx] = to_canvas_coords(mid[0], mid[1])
            ctx.save()
            ctx.beginPath()
            ctx.arc(coping_bump_mid_pos[idx][0], coping_bump_mid_pos[idx][1], 5, 0, 2*math.pi)
            ctx.fillStyle = "#f44"
            ctx.globalAlpha = 0.85
            ctx.fill()
            ctx.strokeStyle = "#222"
            ctx.lineWidth = 1.2
            ctx.stroke()
            ctx.restore()

    show_panel_callouts()

@bind(document["pipeDiameter"], "change")
def on_pipe_diameter(ev):
    global pipe_diameter
    pipe_diameter = max(0.25, parse_fraction(document["pipeDiameter"].value))
    set_default_coping_bump_positions()
    draw_scene()

@bind(document["pipeWall"], "change")
def on_pipe_wall(ev):
    global pipe_wall
    pipe_wall = max(0.01, parse_fraction(document["pipeWall"].value))
    set_default_coping_bump_positions()
    draw_scene()

@bind(document["transitionRadius"], "change")
def on_transition_radius(ev):
    global transition_radius
    new_radius = parse_fraction(document["transitionRadius"].value)
    if new_radius > 0:
        transition_radius = new_radius
        set_default_coping_bump_positions()  # Update coping bump positions
        update_coping_bump_visibility()      # Update angles
        draw_scene()

@bind(document["rampHeight"], "change")
def on_ramp_height(ev):
    global ramp_height
    new_height = parse_fraction(document["rampHeight"].value)
    if new_height > 0:
        ramp_height = new_height
        set_default_coping_bump_positions()  # Update coping bump positions
        update_coping_bump_visibility()      # Update angles
        draw_scene()

@bind(document["arrowUp"], "click")
def move_up(ev): move_pipe(0, 0.01)
@bind(document["arrowDown"], "click")
def move_down(ev): move_pipe(0, -0.01)
@bind(document["arrowLeft"], "click")
def move_left(ev): move_pipe(-0.01, 0)
@bind(document["arrowRight"], "click")
def move_right(ev): move_pipe(0.01, 0)

def move_pipe(dx, dy):
    pipe_pos[0] += dx
    pipe_pos[1] += dy
    set_default_coping_bump_positions()
    draw_scene()

def is_in_crosshair(mx, my, cx, cy, w, h, angle_deg):
    dx = mx - cx
    dy = my - cy
    theta = -deg2rad(angle_deg)
    local_x = dx * math.cos(theta) - dy * math.sin(theta)
    local_y = dx * math.sin(theta) + dy * math.cos(theta)
    return (abs(local_x) < w/2*SCALE+8 and abs(local_y) < h/2*SCALE+8)

@bind(canvas, "mousedown")
def start_drag(ev):
    global dragging, drag_offset
    global coping_bump_mid_drag_idx, coping_bump_mid_drag_offset
    global coping_bump_vertical_only
    mx, my = ev.offsetX, ev.offsetY
    for idx, mline in enumerate(move_lines):
        if mline["show"] and mline["p1"] and mline["p2"]:
            cx, cy = coping_bump_mid_pos[idx]
            if math.hypot(mx - cx, my - cy) < 9:
                coping_bump_mid_drag_idx = idx
                coping_bump_mid_drag_offset = (mx - cx, my - cy)
                return
    for idx, mline in enumerate(move_lines):
        if not mline.get("show", True): continue
        for ptidx in [1, 2]:
            pt = mline["p%d" % ptidx]
            if pt is None: continue
            cpt = to_canvas_coords(pt[0], pt[1])
            if is_in_crosshair(mx, my, cpt[0], cpt[1], mline["hlen"], mline["vlen"], mline["angle%d" % ptidx]):
                mline["dragging"] = ptidx
                coping_bump_vertical_only = True
                return
    x, y = from_canvas_coords(mx, my)
    px, py = pipe_pos
    inner_r = max(0.1, pipe_diameter/2)
    wall_r = max(0.01, pipe_wall)
    outer_r = inner_r + wall_r
    dist = math.hypot(x-px, y-py)
    if dist <= outer_r:
        dragging = True
        drag_offset = (x - px, y - py)

@bind(document, "mousemove")
def do_drag(ev):
    global dragging
    global coping_bump_mid_drag_idx, coping_bump_mid_drag_offset
    if coping_bump_mid_drag_idx is not None:
        rect = canvas.getBoundingClientRect()
        mx, my = ev.clientX - rect.left, ev.clientY - rect.top
        cx, cy = coping_bump_mid_pos[coping_bump_mid_drag_idx]
        dx = (mx - coping_bump_mid_drag_offset[0]) - cx
        dy = (my - coping_bump_mid_drag_offset[1]) - cy
        dx_in = dx / SCALE
        dy_in = -dy / SCALE
        mline = move_lines[coping_bump_mid_drag_idx]
        for pt in ["p1", "p2"]:
            if mline[pt]:
                mline[pt][0] = mline[pt][0] + dx_in
                mline[pt][1] = mline[pt][1] + dy_in
        draw_scene()
        return
    for idx, mline in enumerate(move_lines):
        if not mline.get("show", True): continue
        if mline["dragging"]:
            rect = canvas.getBoundingClientRect()
            x = ev.clientX - rect.left
            y = ev.clientY - rect.top
            lx, ly = from_canvas_coords(x, y)
            ptidx = mline["dragging"]
            if idx == 0:
                if ptidx == 1:
                    mline["p1"][1] = round_nearest_0125(ly)
                else:
                    mline["p2"][1] = round_nearest_0125(ly)
            else:
                angle = deg2rad(mline["angle1"])
                if ptidx == 1:
                    anchor = mline["p2"]
                else:
                    anchor = mline["p1"]
                dx = lx - anchor[0]
                dy = ly - anchor[1]
                ux = math.cos(angle)
                uy = math.sin(angle)
                proj = dx * ux + dy * uy
                proj = round_nearest_0125(proj)
                new_x = anchor[0] + proj * ux
                new_y = anchor[1] + proj * uy
                if ptidx == 1:
                    mline["p1"][0] = new_x
                    mline["p1"][1] = new_y
                else:
                    mline["p2"][0] = new_x
                    mline["p2"][1] = new_y
            draw_scene()
            return
    if not dragging: return
    rect = canvas.getBoundingClientRect()
    x = ev.clientX - rect.left
    y = ev.clientY - rect.top
    lx, ly = from_canvas_coords(x, y)
    offx, offy = drag_offset
    pipe_pos[0] = lx - offx
    pipe_pos[1] = ly - offy
    set_default_coping_bump_positions()
    draw_scene()

@bind(document, "mouseup")
def stop_drag(ev):
    global dragging, coping_bump_mid_drag_idx, coping_bump_vertical_only
    dragging = False
    coping_bump_mid_drag_idx = None
    coping_bump_vertical_only = False
    for mline in move_lines:
        mline["dragging"] = 0

def draw_parallel_line(origin, angle_deg, length_in, offset_inch, color, width, alpha=1.0):
    ang = deg2rad(angle_deg)
    dx = offset_inch * math.sin(ang)
    dy = offset_inch * math.cos(ang)
    new_origin = (origin[0] + dx * SCALE, origin[1] - dy * SCALE)
    return draw_line_pts(new_origin, (
        new_origin[0]+length_in*SCALE*math.cos(deg2rad(angle_deg)),
        new_origin[1]-length_in*SCALE*math.sin(deg2rad(angle_deg))
    ), color, width, alpha, dash=None)

def draw_curved_transition(origin, geom):
    radius_in = geom['radius_in'] 
    angle_rad = geom['angle_rad']
    ramp_angle = geom['ramp_angle']
    
    # Calculate the end point of the transition line (line B)
    # using the ramp angle and transition length
    transition_length_in = geom['transition_length_in']
    
    # Start point (origin)
    start_x, start_y = origin
    
    # Use ramp_angle in radians to ensure correct direction (pointing down)
    ramp_angle_rad = deg2rad(ramp_angle)
    
    # End point calculated using angle (straight line)
    end_x = start_x + (transition_length_in / 12) * SCALE * math.cos(ramp_angle_rad)
    end_y = start_y - (transition_length_in / 12) * SCALE * math.sin(ramp_angle_rad)
    
    # Draw line B (straight line) using the calculated angle - with solid line
    ctx.save()
    ctx.beginPath()
    ctx.moveTo(start_x, start_y)
    ctx.lineTo(end_x, end_y)
    ctx.strokeStyle = "#444"
    ctx.lineWidth = 2
    # Removed the setLineDash to make it a solid line
    ctx.stroke()
    ctx.restore()

def draw_skateboard_surface_layer(origin, geom, thickness_offset, color, width, alpha=1.0):
    radius_in = geom['radius_in']
    angle_rad = geom['angle_rad']
    ramp_angle = geom['ramp_angle']
    transition_length_in = geom['transition_length_in']
    
    # For straight line, we need to offset the origin perpendicular to the ramp angle
    ramp_angle_rad = deg2rad(ramp_angle)
    
    # Calculate perpendicular offset based on thickness
    # Add pi (180 degrees) to get the opposite side of the line
    perp_angle_rad = ramp_angle_rad - math.pi/2
    offset_x = thickness_offset * math.cos(perp_angle_rad)
    offset_y = thickness_offset * math.sin(perp_angle_rad)
    
    # Create new origin with offset
    new_origin_x = origin[0] + offset_x * SCALE
    new_origin_y = origin[1] - offset_y * SCALE
    
    # Calculate end point of the offset line
    end_x = new_origin_x + (transition_length_in / 12) * SCALE * math.cos(ramp_angle_rad)
    end_y = new_origin_y - (transition_length_in / 12) * SCALE * math.sin(ramp_angle_rad)
    
    # Draw the straight line
    ctx.save()
    ctx.beginPath()
    ctx.moveTo(new_origin_x, new_origin_y)
    ctx.lineTo(end_x, end_y)
    ctx.strokeStyle = color
    ctx.lineWidth = width
    ctx.globalAlpha = alpha
    ctx.stroke()
    ctx.globalAlpha = 1.0
    ctx.restore()

def draw_parallel_line_perpendicular(origin, angle_deg, length_in, offset_inch, color, width, alpha=1.0):
    ang = deg2rad(angle_deg)
    perp_angle = angle_deg - 90
    perp_rad = deg2rad(perp_angle)
    dx = offset_inch * math.cos(perp_rad)
    dy = offset_inch * math.sin(perp_rad)
    new_origin = (origin[0] + dx * SCALE, origin[1] - dy * SCALE)
    return draw_line_pts(new_origin, (
        new_origin[0] + length_in * SCALE * math.cos(ang),
        new_origin[1] - length_in * SCALE * math.sin(ang)
    ), color, width, alpha, dash=None)

@bind(canvas, "wheel")
def on_mouse_wheel(ev):
    ev.preventDefault()
    global SCALE
    rect = canvas.getBoundingClientRect()
    mouse_x = ev.clientX - rect.left
    mouse_y = ev.clientY - rect.top
    wx, wy = from_canvas_coords(mouse_x, mouse_y)
    if ev.deltaY < 0:
        new_scale = SCALE * 1.14
    else:
        new_scale = SCALE / 1.14
    new_scale = max(minSCALE, min(maxSCALE, new_scale))
    global CENTER_X, CENTER_Y
    CENTER_X = CANVAS_SIZE // 2
    CENTER_Y = CANVAS_SIZE // 2
    SCALE = new_scale
    draw_scene()

def set_default_coping_bump_positions():
    p1, p2, p3, p4 = get_default_pipes_and_points()
    if coping_bump1_active and move_lines[0]["p1"] is None and move_lines[0]["p2"] is None:
        move_lines[0]["p1"] = list(p1)
        move_lines[0]["p2"] = list(p2)
    if coping_bump2_active and move_lines[1]["p1"] is None and move_lines[1]["p2"] is None:
        move_lines[1]["p1"] = list(p3)
        move_lines[1]["p2"] = list(p4)

@bind(document["toggleCopingBump1"], "click")
def set_coping_bump1(ev):
    global coping_bump1_active
    coping_bump1_active = not coping_bump1_active
    update_coping_bump_visibility()
    btn = document["toggleCopingBump1"]
    if coping_bump1_active:
        if move_lines[0]["p1"] is None or move_lines[0]["p2"] is None:
            p1, p2, _, _ = get_default_pipes_and_points()
            move_lines[0]["p1"] = list(p1)
            move_lines[0]["p2"] = list(p2)
        btn.text = "Unset Coping Bump 1"
    else:
        move_lines[0]["p1"] = None
        move_lines[0]["p2"] = None
        btn.text = "Set Coping Bump 1"
    draw_scene()

@bind(document["toggleCopingBump2"], "click")
def set_coping_bump2(ev):
    global coping_bump2_active
    coping_bump2_active = not coping_bump2_active
    update_coping_bump_visibility()
    btn = document["toggleCopingBump2"]
    if coping_bump2_active:
        if move_lines[1]["p1"] is None or move_lines[1]["p2"] is None:
            _, _, p3, p4 = get_default_pipes_and_points()
            move_lines[1]["p1"] = list(p3)
            move_lines[1]["p2"] = list(p4)
        btn.text = "Unset Coping Bump 2"
    else:
        move_lines[1]["p1"] = None
        move_lines[1]["p2"] = None
        btn.text = "Set Coping Bump 2"
    draw_scene()

@bind(document["toggleFractions"], "click")
def toggle_show_fractions(ev):
    global show_fractions
    show_fractions = not show_fractions
    btn = document["toggleFractions"]
    btn.text = "Show Decimals" if show_fractions else "Show Fractions"
    draw_scene()

pipe_diameter = 2.375
pipe_wall = 0.125
transition_radius = 6.0
ramp_height = 3.0

# Initialize form values
document["pipeDiameter"].value = "2.375"
document["pipeWall"].value = "1/8"
document["transitionRadius"].value = "6.0"
document["rampHeight"].value = "3.0"

coping_bump1_active = False
coping_bump2_active = False
update_coping_bump_visibility()
draw_scene()
# ------ END CANVAS 1 ------

# ------ END CANVAS 1 ------

</script>
<!-- PATCH: Add JavaScript for image upload and draw to canvas 2 -->
<script>
(function() {
    var input = document.getElementById('imageInput');
    var button = document.getElementById('uploadImageBtn');
    var canvas = document.getElementById('imageCanvas');
    var ctx = canvas.getContext('2d');
    var uploadedImg = null;

    button.addEventListener('click', function() {
        input.value = "";
        input.click();
    });

    input.addEventListener('change', function() {
        var file = input.files[0];
        if (!file) return;
        var reader = new FileReader();
        reader.onload = function(e) {
            var img = new window.Image();
            img.onload = function() {
                uploadedImg = img;
                // Draw the image, scaled to fit in the canvas, centered
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                var w = img.width, h = img.height;
                var scale = Math.min(canvas.width/w, canvas.height/h, 1);
                var dw = Math.floor(w * scale), dh = Math.floor(h * scale);
                var x = Math.floor((canvas.width - dw) / 2);
                var y = Math.floor((canvas.height - dh) / 2);
                ctx.drawImage(img, x, y, dw, dh);
                // Optionally: trigger Brython overlay redraw
                if (window.draw_scene_img) window.draw_scene_img();
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    });

    // Optional: make Brython able to redraw the image before overlays
    window._draw_uploaded_image_on_canvas2 = function() {
        if (!uploadedImg) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        var w = uploadedImg.width, h = uploadedImg.height;
        var scale = Math.min(canvas.width/w, canvas.height/h, 1);
        var dw = Math.floor(w * scale), dh = Math.floor(h * scale);
        var x = Math.floor((canvas.width - dw) / 2);
        var y = Math.floor((canvas.height - dh) / 2);
        ctx.drawImage(uploadedImg, x, y, dw, dh);
    };
})();
</script>
</main>
</body>
</html>